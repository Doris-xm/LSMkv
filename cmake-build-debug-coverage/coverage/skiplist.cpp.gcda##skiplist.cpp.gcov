        -:    0:Source:E:/CppProject/dataStruct2023/LSMkv/src/skiplist.cpp
        -:    0:Graph:E:\CppProject\dataStruct2023\LSMkv\cmake-build-debug-coverage\CMakeFiles\LSMkv_correct.dir\src\skiplist.cpp.gcno
        -:    0:Data:E:\CppProject\dataStruct2023\LSMkv\cmake-build-debug-coverage\CMakeFiles\LSMkv_correct.dir\src\skiplist.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "../header/skiplist.h"
        -:    2:
function _ZN8SkipList5clearERP4node called 4604 returned 100% blocks executed 100%
     4604:    3:void SkipList::clear(node *&h) {
     4604:    4:    if( !h ) return;
     4604:    4-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 4599
        5:    4-block  1
     4599:    5:    clear(h->point_list[0]);
     4599:    5-block  0
call    0 returned 4599
call    1 returned 4599
     4599:    6:    delete h;
branch  0 taken 4599 (fallthrough)
branch  1 taken 0
     4599:    6-block  0
call    2 returned 4599
call    3 returned 4599
     4599:    7:    h = nullptr;
     4599:    7-block  0
        -:    8:}
        -:    9:
function _ZN8SkipListD2Ev called 5 returned 100% blocks executed 100%
        5:   10:SkipList::~SkipList() {
        5:   11:    clear(head);
        5:   11-block  0
call    0 returned 5
        5:   12:}
        -:   13:
function _ZN8SkipListC2Ev called 5 returned 100% blocks executed 48%
        5:   14:SkipList::SkipList() {
        5:   15:    P = 368; // probability = 1/e
        5:   16:    tail = new node(-1);//origin used INT_MAX
        5:   16-block  0
call    0 returned 5
call    1 returned 5
branch  2 taken 5 (fallthrough)
branch  3 taken 0 (throw)
        5:   16-block  1
call    4 returned 5
branch  5 taken 5 (fallthrough)
branch  6 taken 0 (throw)
        5:   16-block  2
call    7 returned 5
branch  8 taken 5 (fallthrough)
branch  9 taken 0 (throw)
        5:   16-block  3
call   10 returned 5
call   11 returned 5
    $$$$$:   16-block  4
call   12 never executed
    $$$$$:   16-block  5
call   13 never executed
    $$$$$:   16-block  6
    $$$$$:   16-block  7
call   14 never executed
    $$$$$:   16-block  8
call   15 never executed
        5:   17:    head = new node(0,"",tail);
call    0 returned 5
call    1 returned 5
branch  2 taken 5 (fallthrough)
branch  3 taken 0 (throw)
        5:   17-block  0
call    4 returned 5
branch  5 taken 5 (fallthrough)
branch  6 taken 0 (throw)
        5:   17-block  1
call    7 returned 5
branch  8 taken 5 (fallthrough)
branch  9 taken 0 (throw)
        5:   17-block  2
call   10 returned 5
call   11 returned 5
    $$$$$:   17-block  3
call   12 never executed
    $$$$$:   17-block  4
call   13 never executed
    $$$$$:   17-block  5
    $$$$$:   17-block  6
call   14 never executed
        5:   18:    Max_level = 0;
        5:   19:    key_num = 0;
        5:   20:    max_key = 0;
        5:   21:    min_key = -1;
        5:   22:    Size = 10272; //Header + BloomFilter
        5:   23:}
        -:   24:
        -:   25:/*
        -:   26: * @brief: insert a node into the skiplist,update the Size
        -:   27: * @param key: the key of the node
        -:   28: * @param s: the string of the node
        -:   29: * @return: true :success
        -:   30: *         false: skipList is full
        -:   31: * //TODO: if delete twice?
        -:   32: * */
function _ZN8SkipList6insertEyRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 5125 returned 100% blocks executed 86%
     5125:   33:bool SkipList::insert(uint64_t key, const string &s) {
     5125:   34:    int curr_level = Max_level;
     5125:   35:    node* next = head;
    5125*:   36:    node** update_list = new node*[Max_level + 1];
     5125:   36-block  0
branch  0 taken 5125 (fallthrough)
branch  1 taken 0
     5125:   36-block  1
    %%%%%:   36-block  2
call    2 never executed
     5125:   36-block  3
call    3 returned 5125
branch  4 taken 5125 (fallthrough)
branch  5 taken 0 (throw)
     5125:   37:    if( key > max_key) max_key = key;
     5125:   37-block  0
branch  0 taken 2559 (fallthrough)
branch  1 taken 2566
     2559:   37-block  1
     5125:   38:    if( key < min_key) min_key = key;
     5125:   38-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 5119
        6:   38-block  1
        -:   39:
    91329:   40:    while(curr_level >= 0) {
     5125:   40-block  0
    91329:   40-block  1
branch  0 taken 86739
branch  1 taken 4590 (fallthrough)
    86739:   41:        if( key < next->point_list[curr_level]->key) {
    86739:   41-block  0
call    0 returned 86739
branch  1 taken 34046 (fallthrough)
branch  2 taken 52693
    34046:   42:            update_list[curr_level] = next;//后续可能需要更新
    34046:   43:            curr_level--;
    34046:   44:            continue;
    34046:   44-block  0
        -:   45:        }
    52693:   46:        if( key == next->point_list[curr_level]->key){
    52693:   46-block  0
call    0 returned 52693
branch  1 taken 535 (fallthrough)
branch  2 taken 52158
      535:   47:            delete []update_list;
      535:   47-block  0
branch  0 taken 535 (fallthrough)
branch  1 taken 0
      535:   47-block  1
call    2 returned 535
      535:   48:            string old = next->point_list[curr_level]->s;
      535:   48-block  0
call    0 returned 535
call    1 returned 535
branch  2 taken 535 (fallthrough)
branch  3 taken 0 (throw)
      535:   49:            if(Size + s.size() - old.size() > CAPACITY)
      535:   49-block  0
call    0 returned 535
call    1 returned 535
branch  2 taken 0 (fallthrough)
branch  3 taken 535
    #####:   50:                return false;
    %%%%%:   50-block  0
      535:   51:            next->point_list[curr_level]->s = s;
      535:   51-block  0
call    0 returned 535
call    1 returned 535
branch  2 taken 535 (fallthrough)
branch  3 taken 0 (throw)
      535:   52:            Size += s.size() - old.size();
      535:   52-block  0
call    0 returned 535
call    1 returned 535
      535:   53:            return true;
      535:   54:        }
      535:   54-block  0
call    0 returned 535
    $$$$$:   54-block  1
call    1 never executed
    52158:   55:        if( key > next->point_list[curr_level]->key)
    52158:   55-block  0
call    0 returned 52158
branch  1 taken 52158 (fallthrough)
branch  2 taken 0
    52158:   56:            next = next->point_list[curr_level];
    52158:   56-block  0
call    0 returned 52158
        -:   57:    }
        -:   58:
     4590:   59:    if(Size + s.size() + 13 > CAPACITY) {
     4590:   59-block  0
call    0 returned 4590
branch  1 taken 1 (fallthrough)
branch  2 taken 4589
        1:   60:        delete []update_list;
        1:   60-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   60-block  1
call    2 returned 1
        1:   61:        return false;
        1:   61-block  0
        -:   62:    }
     4589:   63:    node* NewNode = new node(key, s,next->point_list[0]);
     4589:   63-block  0
call    0 returned 4589
branch  1 taken 4589 (fallthrough)
branch  2 taken 0 (throw)
     4589:   63-block  1
call    3 returned 4589
call    4 returned 4589
branch  5 taken 4589 (fallthrough)
branch  6 taken 0 (throw)
     4589:   63-block  2
call    7 returned 4589
branch  8 taken 4589 (fallthrough)
branch  9 taken 0 (throw)
     4589:   63-block  3
call   10 returned 4589
    $$$$$:   63-block  4
call   11 never executed
    $$$$$:   63-block  5
call   12 never executed
    $$$$$:   63-block  6
     4589:   64:    key_num ++;
     4589:   65:    Size += s.size() + 13; // 1 + 8 + 4: '\0' + key + offset
call    0 returned 4589
     4589:   66:    next->point_list[0] = NewNode;
call    0 returned 4589
        -:   67:
        -:   68://    srand(time(nullptr));
     4589:   69:    int r = rand() % 1000;
call    0 returned 4589
     7275:   70:    while(r % 1000 < P){
     7275:   70-block  0
branch  0 taken 2706
branch  1 taken 4569 (fallthrough)
     2706:   71:        r = rand() % 1000;
     2706:   71-block  0
call    0 returned 2706
     2706:   72:        NewNode->level++;
     2706:   73:        if(NewNode->level > Max_level) {
branch  0 taken 20 (fallthrough)
branch  1 taken 2686
       20:   74:            Max_level++;
       20:   75:            head->point_list.push_back(NewNode);
       20:   75-block  0
call    0 returned 20
branch  1 taken 20 (fallthrough)
branch  2 taken 0 (throw)
       20:   76:            NewNode->point_list.push_back(tail);
       20:   76-block  0
call    0 returned 20
branch  1 taken 20 (fallthrough)
branch  2 taken 0 (throw)
       20:   77:            head->level++;
       20:   78:            tail->level++;
       20:   79:            break;
       20:   79-block  0
        -:   80:        }
        -:   81:        else {
     2686:   82:            NewNode->point_list.push_back( update_list[NewNode->level] -> point_list[NewNode->level] );
     2686:   82-block  0
call    0 returned 2686
call    1 returned 2686
branch  2 taken 2686 (fallthrough)
branch  3 taken 0 (throw)
     2686:   83:            update_list[NewNode->level] -> point_list[NewNode->level] = NewNode;
     2686:   83-block  0
call    0 returned 2686
        -:   84:        }
        -:   85:    }
     4589:   86:    delete []update_list;
     4589:   86-block  0
branch  0 taken 4589 (fallthrough)
branch  1 taken 0
     4589:   86-block  1
call    2 returned 4589
     4589:   87:    return true;
     4589:   87-block  0
        -:   88:}
        -:   89:
function _ZN8SkipList6searchB5cxx11Ey called 13813 returned 100% blocks executed 89%
    13813:   90:std::string SkipList::search(uint64_t key) {
    13813:   91:    int curr_level = Max_level;
    13813:   92:    node* next = head;
        -:   93:
   202319:   94:    while(curr_level >= 0) {
    13813:   94-block  0
   202319:   94-block  1
branch  0 taken 195216
branch  1 taken 7103 (fallthrough)
   195216:   95:        if( key == next->point_list[curr_level]->key)
   195216:   95-block  0
call    0 returned 195216
branch  1 taken 6710 (fallthrough)
branch  2 taken 188506
     6710:   96:            return next->point_list[curr_level]->s;
     6710:   96-block  0
call    0 returned 6710
call    1 returned 6710
        -:   97:
   188506:   98:        if( key < next->point_list[curr_level]->key)
   188506:   98-block  0
call    0 returned 188506
branch  1 taken 75951 (fallthrough)
branch  2 taken 112555
    75951:   99:            curr_level--;
    75951:   99-block  0
        -:  100:        else
   112555:  101:            next = next->point_list[curr_level];
   112555:  101-block  0
call    0 returned 112555
        -:  102:    }
        -:  103:
     7103:  104:    return "";
     7103:  104-block  0
call    0 returned 7103
call    1 returned 7103
branch  2 taken 7103 (fallthrough)
branch  3 taken 0 (throw)
     7103:  104-block  1
call    4 returned 7103
    $$$$$:  104-block  2
call    5 never executed
        -:  105:}
        -:  106:
function _ZN8SkipList4scanEyyRNSt7__cxx114listISt4pairIyNS0_12basic_stringIcSt11char_traitsIcESaIcEEEESaIS8_EEE called 2 returned 100% blocks executed 74%
        2:  107:bool SkipList::scan(uint64_t key1, uint64_t key2, list<std::pair<uint64_t, std::string>> &list) {
        2:  108:    if(key1 > max_key || key2 < min_key) return false;
        2:  108-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  108-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        1:  108-block  2
      257:  109:    for(int i = key1; i <= key2; ++i) {
        1:  109-block  0
      257:  109-block  1
branch  0 taken 256
branch  1 taken 1 (fallthrough)
      256:  110:        string tmp = search(i);
      256:  110-block  0
call    0 returned 256
branch  1 taken 256 (fallthrough)
branch  2 taken 0 (throw)
      256:  111:        if( ! tmp.empty())
      256:  111-block  0
call    0 returned 256
branch  1 taken 256 (fallthrough)
branch  2 taken 0
      256:  112:            list.emplace_back(std::make_pair(i, tmp));
      256:  112-block  0
call    0 returned 256
branch  1 taken 256 (fallthrough)
branch  2 taken 0 (throw)
      256:  112-block  1
call    3 returned 256
branch  4 taken 256 (fallthrough)
branch  5 taken 0 (throw)
      256:  112-block  2
call    6 returned 256
    $$$$$:  112-block  3
call    7 never executed
    $$$$$:  112-block  4
      256:  113:    }
      256:  113-block  0
call    0 returned 256
    $$$$$:  113-block  1
call    1 never executed
        1:  114:    return true;
        1:  114-block  0
        -:  115:}
        -:  116:
        -:  117:
function _ZN8SkipList3delEy called 0 returned 0% blocks executed 0%
    #####:  118:int SkipList::del(uint64_t key) {
    #####:  119:    return false;
    %%%%%:  119-block  0
        -:  120:}
        -:  121:
        -:  122://void SkipList::store(const string &path, const uint64_t timestamp) {
        -:  123://    ofstream out(path, ios::binary | ios::app);
        -:  124://
        -:  125://    // Header
        -:  126://    out.write((char*)&timestamp, sizeof(uint64_t));
        -:  127://    out.write((char*)&key_num, sizeof(uint64_t));
        -:  128://    out.write((char*)&min_key, sizeof(uint64_t));
        -:  129://    out.write((char*)&max_key, sizeof(uint64_t));
        -:  130://
        -:  131://    // Bloom Filter
        -:  132://    uint32_t hash[4] = {0};
        -:  133://    node *curr = head->point_list[0];
        -:  134://    while(curr != tail) {
        -:  135://        MurmurHash3_x64_128(&curr->key, sizeof(uint64_t), 1, hash);
        -:  136://        for(int i = 0; i < 4; ++i)
        -:  137://            bits.set(hash[i] % 81920);
        -:  138://        curr = curr->point_list[0];
        -:  139://    }
        -:  140://    out.write((char*)&bits, sizeof(bits));
        -:  141://
        -:  142://    // key + offset
        -:  143://    uint32_t offset = 10272 + key_num * 12; //begin of value area, 12 = key + offset = 8 + 4
        -:  144://    curr = head->point_list[0];
        -:  145://    while(curr != tail) {
        -:  146://        out.write((char*)&curr->key, sizeof(uint64_t));
        -:  147://        out.write((char*)&offset, sizeof(uint32_t));
        -:  148://        offset += curr->s.size() + 1;
        -:  149://        curr = curr->point_list[0];
        -:  150://    }
        -:  151://
        -:  152://    // Data area
        -:  153://    curr = head->point_list[0];
        -:  154://    while(curr != tail) {
        -:  155://        out.write(curr->s.c_str(), curr->s.size());
        -:  156://        out.write("\0", 1);
        -:  157://        curr = curr->point_list[0];
        -:  158://    }
        -:  159://    out.close();
        -:  160://}
        -:  161:
